// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: jobs.sql

package pgdao

import (
	"context"
	"database/sql"
	"time"
)

const jobAdd = `-- name: JobAdd :one
insert into jobs (
    id, title, description, budget, duration, created_by
) values (
    $1, $2, $3, $4, $5, $6
) returning id, title, description, budget, duration, created_at, updated_at, created_by, blocked_at, suspended_at, visibility
`

type JobAddParams struct {
	ID          string
	Title       string
	Description string
	Budget      sql.NullString
	Duration    sql.NullInt32
	CreatedBy   string
}

func (q *Queries) JobAdd(ctx context.Context, arg JobAddParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, jobAdd,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Budget,
		arg.Duration,
		arg.CreatedBy,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Budget,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.BlockedAt,
		&i.SuspendedAt,
		&i.Visibility,
	)
	return i, err
}

const jobBlock = `-- name: JobBlock :exec
update jobs set blocked_at = now() where id = $1::varchar
`

func (q *Queries) JobBlock(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, jobBlock, id)
	return err
}

const jobFind = `-- name: JobFind :one
select id, title, description, budget, duration, created_at, updated_at, created_by, blocked_at, suspended_at, visibility from jobs where id = $1::varchar
`

// It is used only for testing purposes.
func (q *Queries) JobFind(ctx context.Context, id string) (Job, error) {
	row := q.db.QueryRowContext(ctx, jobFind, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Budget,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.BlockedAt,
		&i.SuspendedAt,
		&i.Visibility,
	)
	return i, err
}

const jobGet = `-- name: JobGet :one
select
    j.id
    ,j.title
    ,j.description
    ,j.budget
    ,j.duration
    ,j.created_at
    ,j.created_by
    ,j.updated_at
    ,j.suspended_at
    ,(select count(*) from applications a where a.job_id = j.id) as application_count
    ,(CASE WHEN p.display_name = '' THEN p.login ELSE p.display_name END)::varchar AS customer_display_name
    ,p.ethereum_address AS customer_ethereum_address
    from jobs j
    join persons p on p.id = j.created_by
    where j.id = $1::varchar and j.blocked_at is null
`

type JobGetRow struct {
	ID                      string
	Title                   string
	Description             string
	Budget                  sql.NullString
	Duration                sql.NullInt32
	CreatedAt               time.Time
	CreatedBy               string
	UpdatedAt               time.Time
	SuspendedAt             sql.NullTime
	ApplicationCount        int64
	CustomerDisplayName     string
	CustomerEthereumAddress string
}

func (q *Queries) JobGet(ctx context.Context, id string) (JobGetRow, error) {
	row := q.db.QueryRowContext(ctx, jobGet, id)
	var i JobGetRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Budget,
		&i.Duration,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.SuspendedAt,
		&i.ApplicationCount,
		&i.CustomerDisplayName,
		&i.CustomerEthereumAddress,
	)
	return i, err
}

const jobHide = `-- name: JobHide :exec
update jobs set visibility = 'hidden' where id = $1::varchar
`

func (q *Queries) JobHide(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, jobHide, id)
	return err
}

const jobPatch = `-- name: JobPatch :one
update jobs
set
    title = $1::varchar,
    description = $2::varchar,
    budget = $3::decimal,
    duration = $4::int,
    updated_at = now()
where
    id = $5::varchar and $6::varchar = created_by
returning id, title, description, budget, duration, created_at, updated_at, created_by, blocked_at, suspended_at, visibility
`

type JobPatchParams struct {
	Title       string
	Description string
	Budget      string
	Duration    int32
	ID          string
	Actor       string
}

func (q *Queries) JobPatch(ctx context.Context, arg JobPatchParams) (Job, error) {
	row := q.db.QueryRowContext(ctx, jobPatch,
		arg.Title,
		arg.Description,
		arg.Budget,
		arg.Duration,
		arg.ID,
		arg.Actor,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Budget,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.BlockedAt,
		&i.SuspendedAt,
		&i.Visibility,
	)
	return i, err
}

const jobResume = `-- name: JobResume :exec
update jobs set suspended_at = null where id = $1::varchar
`

func (q *Queries) JobResume(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, jobResume, id)
	return err
}

const jobSuspend = `-- name: JobSuspend :exec
update jobs set suspended_at = now() where id = $1::varchar
`

func (q *Queries) JobSuspend(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, jobSuspend, id)
	return err
}

const jobsList = `-- name: JobsList :many
select
     j.id
    ,j.title
    ,j.description
    ,j.budget
    ,j.duration
    ,j.created_at
    ,j.created_by
    ,j.updated_at
    ,(select count(*) from applications a where a.job_id = j.id) as application_count
    ,(CASE WHEN p.display_name = '' THEN p.login ELSE p.display_name END)::varchar AS customer_display_name
    ,p.ethereum_address AS customer_ethereum_address
    from jobs j
    join persons p on p.id = j.created_by
    where j.blocked_at is null and j.suspended_at is null and j.visibility = 'public'
    order by j.updated_at desc
`

type JobsListRow struct {
	ID                      string
	Title                   string
	Description             string
	Budget                  sql.NullString
	Duration                sql.NullInt32
	CreatedAt               time.Time
	CreatedBy               string
	UpdatedAt               time.Time
	ApplicationCount        int64
	CustomerDisplayName     string
	CustomerEthereumAddress string
}

func (q *Queries) JobsList(ctx context.Context) ([]JobsListRow, error) {
	rows, err := q.db.QueryContext(ctx, jobsList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobsListRow
	for rows.Next() {
		var i JobsListRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Budget,
			&i.Duration,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.ApplicationCount,
			&i.CustomerDisplayName,
			&i.CustomerEthereumAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const jobsPurge = `-- name: JobsPurge :exec
DELETE FROM jobs
`

// Handle with care!
func (q *Queries) JobsPurge(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, jobsPurge)
	return err
}
