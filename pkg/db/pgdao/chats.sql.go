// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: chats.sql

package pgdao

import (
	"context"
	"database/sql"
	"time"
)

const chatAdd = `-- name: ChatAdd :one
insert into chats (
    id, topic
) values (
    $1, $2
) returning id, topic, created_at
`

type ChatAddParams struct {
	ID    string
	Topic string
}

func (q *Queries) ChatAdd(ctx context.Context, arg ChatAddParams) (Chat, error) {
	row := q.db.QueryRowContext(ctx, chatAdd, arg.ID, arg.Topic)
	var i Chat
	err := row.Scan(&i.ID, &i.Topic, &i.CreatedAt)
	return i, err
}

const chatGet = `-- name: ChatGet :one
select
    c.id, c.topic, c.created_at
from chats c
where c.id = $1::varchar
`

func (q *Queries) ChatGet(ctx context.Context, id string) (Chat, error) {
	row := q.db.QueryRowContext(ctx, chatGet, id)
	var i Chat
	err := row.Scan(&i.ID, &i.Topic, &i.CreatedAt)
	return i, err
}

const chatGetByTopic = `-- name: ChatGetByTopic :one
select
    c.id, c.topic, c.created_at
from chats c
where c.topic = $1::varchar
`

func (q *Queries) ChatGetByTopic(ctx context.Context, topic string) (Chat, error) {
	row := q.db.QueryRowContext(ctx, chatGetByTopic, topic)
	var i Chat
	err := row.Scan(&i.ID, &i.Topic, &i.CreatedAt)
	return i, err
}

const chatGetDetailsByApplicationID = `-- name: ChatGetDetailsByApplicationID :one
select
      a.id as application_id
    , j.id as job_id
    , j.title as job_title
    , c.id as contract_id
from applications a
join jobs j on a.job_id = j.id
left join contracts c on a.id = c.application_id
where a.id = $1::varchar
`

type ChatGetDetailsByApplicationIDRow struct {
	ApplicationID string
	JobID         string
	JobTitle      string
	ContractID    sql.NullString
}

func (q *Queries) ChatGetDetailsByApplicationID(ctx context.Context, applicationID string) (ChatGetDetailsByApplicationIDRow, error) {
	row := q.db.QueryRowContext(ctx, chatGetDetailsByApplicationID, applicationID)
	var i ChatGetDetailsByApplicationIDRow
	err := row.Scan(
		&i.ApplicationID,
		&i.JobID,
		&i.JobTitle,
		&i.ContractID,
	)
	return i, err
}

const chatParticipantAdd = `-- name: ChatParticipantAdd :one
insert into chats_participants (
    chat_id, person_id
) values (
    $1, $2
) returning chat_id, person_id
`

type ChatParticipantAddParams struct {
	ChatID   string
	PersonID string
}

func (q *Queries) ChatParticipantAdd(ctx context.Context, arg ChatParticipantAddParams) (ChatsParticipant, error) {
	row := q.db.QueryRowContext(ctx, chatParticipantAdd, arg.ChatID, arg.PersonID)
	var i ChatsParticipant
	err := row.Scan(&i.ChatID, &i.PersonID)
	return i, err
}

const chatParticipantGet = `-- name: ChatParticipantGet :one
select
    cp.chat_id, cp.person_id
from chats_participants cp
where
    cp.chat_id = $1::varchar
    and cp.person_id = $2::varchar
`

type ChatParticipantGetParams struct {
	ChatID   string
	PersonID string
}

func (q *Queries) ChatParticipantGet(ctx context.Context, arg ChatParticipantGetParams) (ChatsParticipant, error) {
	row := q.db.QueryRowContext(ctx, chatParticipantGet, arg.ChatID, arg.PersonID)
	var i ChatsParticipant
	err := row.Scan(&i.ChatID, &i.PersonID)
	return i, err
}

const chatsListByParticipant = `-- name: ChatsListByParticipant :many
select
      c.id, c.topic, c.created_at
    , p.id as person_id
    , p.display_name as person_display_name
    , p.ethereum_address as person_ethereum_address
    , m1.created_at as last_message_at
from chats c
join chats_participants cp on c.id = cp.chat_id
join persons p on p.id = cp.person_id
join messages m1 on c.id = m1.chat_id
left outer join messages m2 on (c.id = m2.chat_id and m1.created_at < m2.created_at)
where c.id in (select chat_id from chats_participants where person_id = $1::varchar)
and m2.id is null
order by m1.created_at desc, c.id
`

type ChatsListByParticipantRow struct {
	ID                    string
	Topic                 string
	CreatedAt             time.Time
	PersonID              string
	PersonDisplayName     string
	PersonEthereumAddress string
	LastMessageAt         time.Time
}

// Chat list order by created_at timestamp of the latest message that belongs chat. Order is inverse from the newest to the latest update.
func (q *Queries) ChatsListByParticipant(ctx context.Context, participantID string) ([]ChatsListByParticipantRow, error) {
	rows, err := q.db.QueryContext(ctx, chatsListByParticipant, participantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatsListByParticipantRow
	for rows.Next() {
		var i ChatsListByParticipantRow
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.CreatedAt,
			&i.PersonID,
			&i.PersonDisplayName,
			&i.PersonEthereumAddress,
			&i.LastMessageAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const chatsPurge = `-- name: ChatsPurge :exec
DELETE FROM chats
`

// Handle with care!
func (q *Queries) ChatsPurge(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, chatsPurge)
	return err
}
